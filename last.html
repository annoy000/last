#2nd maximimum in array 
int main()
{
    // Write your code here
    int n;
    cin>>n;
    int arr[n];
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    int max=arr[0];
    int max2=0;
    for(int i=0;i<n;i++){
        if(arr[i]>max){
            max2=max;
            max=arr[i];
        }
        if(arr[i]<max && arr[i]>max2){
            max2=arr[i];
        }
    }
cout<<max2;
    return 0;
}

#maximum frequency
int maxFrequency(int A[], int n) {
  // Write your code here
  int arr[1001]={0};
    for(int i=0;i<n;i++){
        arr[A[i]]++;
    }
    int maxf=-1, maxe;
    for(int i=0;i<1001;i++){
        if(arr[i]>maxf){
            maxf=arr[i];
            maxe=i;
        }
    }
    return maxe;
}

#count negative pos even odd
void countAndPrint(int x[],int n){
  //write your code here
    int p=0,ne=0,e=0,o=0;
    for(int i=0;i<n;i++){
        if(x[i]<0){
            ne++;
        }
        if(x[i]>0){
            p++;
        }
        if(x[i]%2==0){
            e++;
        }
        if(x[i]%2!=0){
            o++;
        }
    }
  cout<<p<<endl<<ne<<endl<<e<<endl<<o<<endl;
}

#check if two arrays are equal  
#include <algorithm>  
bool ArrayComparator:: areArraysEqual()
     {
      sort(arr1,arr1+size);
      sort(arr2,arr2+size);
    for(int i=0;i<size;i++){
      if(arr1[i]!=arr2[i]){
          return false;
      }
    }
       return true;
     }

#move the elements 
void swap(int &a,int &b){
    int c=a;
    a=b;
    b=c;
}
void Result::moveElements()
{
    int pos=0;
    for(int i=0;i<size;i++){
        if(arr[i]>=0){
            for(int k=i;k>pos;k--){
                swap(arr[k],arr[k-1]);
            }
            pos++;
        }
    }
}


#string length
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n,l;
    cin>>n;
    while(n--){
        string str;
        cin>>str;
        l=str.length();
        cout<<l<<endl;
    }
   return 0;
}

#strmp function 
int StringCmp::strcmp() {
    for(int i=0;i<str1.size() && i<str2.size();i++){
        if(str1[i] != str2[i]){
            return str1[i]-str2[i];
        }
    }
  return 0;
}

#strat function 
void strcatCode(char* str1, char* str2) {
  // Write your code here
    while(*str1){
        *str1++;
    }
    while(*str2){
        *str1++=*str2++;
    }
  *str1='\0';
}

#unique characyrrs or not
// Return true if string contains all unique characters, else return false
bool isUniqueChars(string str){
  // Write your code here
    int flag=0;
    int n=str.length();
    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            if(str[i]==str[j]){
                flag=1;
            }
        }
    }
    if (flag==1){
        return false;
    }
    else {
        return true;
    }
}

#string is palindrom
// Return true if the string is palindrome, else return false
bool isPalindrome(string str) {
  // Write your code here
  int l=str.length();
    for(int i=0,j=l-1;i<l;i++,j--){
        if(str[i]!=str[j]){
            return 0;
        }
    }
    return 1;
}

#reverse a string   
// Do not print anything, just reverse the given string
void reverseString (string &str) {
  // Write your code here
    int l=str.length();
    int start=0;
    int end=l-1;
    while(start<end){
        char temp=str[start];
        str[start]=str[end];
        str[end]=temp;
        start++;
        end--;   
    }
}

#count words
int countWords(string str) {
  // Write your code here
    int l=str.length();
    int count=0;
    if(l==0){
        count=-1;
    }
    for(int i=0;i<l;i++){
        if(str[i]!=' '&&str[i+1]==' '){
            count++;
        }
    }
    return count+1;
}

#reverse the words of string
void revWordsString(string str) {
  int start=0;
    int end=0;
    int l=str.length();
    for(int i=0;i<=l;i++){
        if(str[i]==' ' || i==l){
            end=i-1;
            while(start<end){
                char temp=str[start];
                str[start]=str[end];
                str[end]=temp;
                start++;
                end--;
            }
            start=i+1;
        }
    }
  cout<<str;
}

#first unique character
#include<unordered_map>
int firstUniqueChar(string str) {
    unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<str.size();i++){
        if(s[str[i]] == 1){
            return i;
        }
    }
    return -1;
}

#fins all pairs with k diffrences
#include<unordered_map>
int getPairsCount(int arr[], int n, int k) {
unordered_map<int,int> s;
    for(int i=0;i<n;i++){
        s[arr[i]]++;
    }
    int c=0;
    for(int i=0;i<n;i++){
        int t=arr[i]-k;
        if(s.find(t) != s.end()){
            c++;
        }
    }
    return c;
}

#find out the winner
#include<unordered_map>
string inspectStrings(vector<string> words) {
    map<string,int>s;
for(int i=0;i<words.size();i++){
    s[words[i]]++;
}  
    int max=0;
    string r;
    for(auto i:s){
        if(i.second >= max){
            r=i.first;
            max=i.second;
        }
    }
    return r;
}

#unique chracters or not
// Return true if string contains all unique characters, else return false
#include<unordered_map>
bool isUniqueChars(string str){
unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<s.size();i++){
        if(s[str[i]]>1){
            return false;
        }
    }
return true;
}

#frequency of each character
void countFrequency(string str) {
unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<str.size();i++){
        if(s[str[i]]>=1){
            cout<<str[i]<<s[str[i]]<<" ";
            s[str[i]]=0;
    }
}
}

#kth distinct elements
int kthDistinctElement(vector<int> arr, int n, int k) {
  unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        s[arr[i]]++;
    }
    int c=0;
    for(int i=0;i<n;i++){
        if(s[arr[i]] == 1){
            c++;
        }
        if(c == k){
            return arr[i];
        }
    }
    return 0;
}

#maximum frequency in sequence
int maxFrequency(int A[], int n) {
map<int,int>s;
    for(int i=0;i<n;i++){
        s[A[i]]++;
    }
    int max=0;
    int r=-1;
  for(auto i:s){
      if(i.second > max){
         max=i.second;
         r=i.first;
      }
  }
    return r;
}

#check if two arrays are equal or not
int arraysEqualorNot(vector<int> A, vector<int> B) {
  sort(A.begin(),A.end());
    sort(B.begin(),B.end());
    for(int i=0;i<A.size();i++){
        if(A[i] != B[i]){
            return 0;
        }
    }
    return 1;
}

#pair with given sum
// Return true if a pair with the sum k is found, else return false
bool pairSum(int arr[], int n, int k) {
  unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        int t=k-arr[i];
        if(s.find(t) != s.end()){
            return true;
        }
        s[arr[i]]++;
    }
    return false;
}

#aaray pair sum divisibility problem
int isArrayDivisibleInPairs(int a[], int n, int k){
unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        int r=a[i]%k;
        if(r<0){
            r+=k;
        }
        s[r]++;
    }
    if(s[0]%2!=0){
        return false;
    }
for(int i=1;i<k/2;i++){
    if(s[i] != s[k-1]){
        return false;
    }
}
return true;
}

#largest subaaray with zero sum
int largSubArray(int* arr, int n){
 unordered_map<int,int>s;
    int sum=0;
    int maxl=-1;
    for(int i=0;i<n;i++){
        sum+=arr[i];
        if(sum == 0){
            maxl=i+1;
        }
        if(s.find(sum) != s.end()){
            int max=i-s[sum];
            if(max>maxl){
                maxl=max;
            }
        }
        else{
            s[sum]=i;
        }
    }
    return maxl;
}

#create a binary tree from array
// Complete the buildTree() function which is a member function of the class BinaryTree.
void BinaryTree:: buildTree(int arr[], int n) {
    if(n == 0){
        return ;
    }
  queue <TreeNode*>q;
    root = new TreeNode(arr[0]);
    q.push(root);
    int inde=1;
    while(inde<n){
        TreeNode *temp=q.front();
           q.pop();
        if(inde<n){
            temp->left = new TreeNode (arr[inde++]);
            q.push(temp->left);
        }
         if(inde<n){
             temp->right=new TreeNode (arr[inde++]);
             q.push(temp->right);
         }
    }
}

#print binary tree in level order transversal
void Tree::printLevelWise() {
    if( root == NULL){
        return ;
    }
  queue<Node*>q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
      Node *temp=q.front();
        q.pop();
        cout<<temp->data;          
        if(i != (size-1)){
            cout<<" ";
        }
        if(temp->left){
            q.push(temp->left);
        }
        if(temp->right){
            q.push(temp->right);
        }
    }
        cout<<endl;
    }
}

#print nodes at odd level of binary tree
void printOdd(Node* root){
    if(root == NULL){
        return ;
    }
    queue<Node*>q;
    q.push(root);
    int ind=1;
    while(!q.empty()){
      int size=q.size();
        for(int i=0;i<size;i++){
            Node *temp=q.front();
            q.pop();
            if(ind%2==1){
                cout<<temp->data<<" ";
            }
            if(temp->left){
                q.push(temp->left);
            }
            if(temp->right){
                q.push(temp->right);
            }
        }
        ind++;
    }
}

#Complete the inorder(), preorder() and postorder() functions for traversal with recursion
 void inorder(Node *root) {
if(root == NULL){
    return ;
}
      inorder(root->left);
      cout<<root->data<<" ";
      inorder(root->right);
  }
   void  preorder(Node *root) {
       if(root == NULL){
    return ;
}
      cout<<root->data<<" ";
       preorder(root->left);
      preorder(root->right);
    }
    void  postorder(Node *root) {
     if(root == NULL){
    return ;
}
        postorder(root->left);
        postorder(root->right);
        cout<<root->data<<" ";
    }

#Count the number of leaf and non-leaf nodes in a binary tree
// These are the functions of the class BinaryTree in head and complete it in body.
int BinaryTree::countLeafs(TreeNode* node) {
if(node == nullptr){
    return 0;
}
    if(node->left == nullptr && node->right == nullptr){
        return 1;
    }
    return countLeafs(node->left) + countLeafs(node->right);
}
int BinaryTree::countNonLeafs(TreeNode* node) {
if(node == nullptr){
    return 0;
}
    if(node->left == nullptr && node->right == nullptr){
        return 0;
    }
    return countNonLeafs(node->left) + countNonLeafs(node->right)+1;
}

#Print all paths to leaves and their details of a binary tree
void printAllPaths(Node *root,vector<int>path){
      static int count=0;
      if(root == NULL){
      return ;
  }
      path.push_back(root->data);
      if(root->left == NULL && root->right == NULL){
          for(int i=0;i<path.size();i++){
              cout<<path[i]<<" ";
          }
          cout<<path.size()-1<<endl;
          count++;
          path.pop_back();
          return ;
      }
      printAllPaths(root->left,path);
      printAllPaths(root->right,path);
      path.pop_back();
      if(path.empty()){
          cout<<count<<endl;
      }
  }
void printAllPaths(Node* root) {
  if(root == NULL){
      return ;
  }
    vector<int>path;
  printAllPaths(root,path);
}

#Find the right node of a given node
int BinaryTree::findRightSibling(int key) {
    if(root->data == key){
        return -1;
    }
    queue<Node*>q;
    q.push(root);
    while(!q.empty()){
      int size=q.size();
         while(size>0){
            Node *temp=q.front();
             q.pop();
            if(temp->data == key){
                if(!q.empty() && size != 1){
                    Node *r=q.front();
                    q.pop();
                    return r->data;
                }
                else{
                    return -1;
                }
            }
             if(temp->left){
                 q.push(temp->left);
             }
             if(temp->right){
                 q.push(temp->right);
             }
             size--;
         }
    }
    return -1;
}

#Given list is circular or not
int ListCircularCheck::isCircular(Node* head) {
    if(head == nullptr){
        return 1;
    }
    Node *slow=head;
    Node *fast=head;
    while(fast != nullptr && fast->next != nullptr){
        slow=slow->next;
        fast=fast->next->next;
    if(slow == head){
        return 1;
    }
    if(fast == slow){
        return 0;
    }
    }
}

#Insert Nodes in a Circular Linked List
Node* insertBeg(Node* head, int data){
    Node *newnode =new Node(data);
    if(head == NULL){
        head=newnode;
        newnode->next=head;
        return head;
    }
    Node *temp=head;
    while(temp->next != head){
      temp=temp->next;
    }
    temp->next=newnode;
    newnode->next=head;
    head=newnode;
    return head;
}
Node* insertEnd(Node* head, int data){
     Node *newnode =new Node(data);
      if(head == NULL){
          head=newnode;
          newnode->next=head;
          return head;
      }
    Node *temp=head;
    while(temp->next != head){
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->next=head;
    return head;
}

#Delete in Circular Linked List
void CircularLinkedList::deleteBeg(){
Node *temp=head;
    while(temp->next != head){
        temp=temp->next;
    }
    Node *te=head;
    temp->next=head->next;
    head=head->next;
    delete te;
}
void CircularLinkedList::deleteEnd(){
   Node *temp=head;
    while(temp->next->next != head){
        temp=temp->next;
    }
    Node *res=temp->next;
    temp->next=head;
    delete res;
}

#Count the Number of Nodes in Circular Linked List
int LinkedList::countNodes() {
    if(head == nullptr || head->next == nullptr){
        return 0;
    }
  int c=1;
    Node *temp=head;
    while(temp->next != head)
    {
        temp=temp->next;
          c++;
    }
    return c;
}

#Insert in a sorted circular linked list
void CircularLinkedList::insertSorted(int newData) {
      Node *newnode = new Node(newData);
     if(head == NULL){
         newnode->next=newnode;
         head=newnode;
     }
         Node *temp=head;
          if(newData < head->data){
              while(temp->next != head){
                  temp=temp->next;
              }
              temp->next=newnode;
              newnode->next=head;
              head=newnode;
              return;
          }
         while(temp->next != head && temp->next->data < newData){
             temp=temp->next;
         }
         newnode->next=temp->next;
     temp->next=newnode;
 }

 #Split the Circular Linked List in two parts
 CircularLinkedList* CircularLinkedList::splitLinkedList()
    {
    CircularLinkedList *newnode = new CircularLinkedList();
    if(head == nullptr){
        newnode->head=nullptr;
        return newnode;
    }
    LinkNode *tail=head;
    while(tail->next !=head){
        tail=tail->next;
    }
    LinkNode *slow=head;
    LinkNode *fast=head;
    while(fast->next->next != head){
        slow=slow->next;
        fast=fast->next->next;
    }
    newnode->head=slow->next;
    slow->next=head;
    tail->next=newnode->head;
    return newnode;
}

#Swap Two Nodes of Doubly Linked List
void LinkedList::swapNodes(int x, int y) {
Node *slow=head;
    Node *fast=head;
    while(slow != NULL && slow->data != x){
        slow=slow->next;
    }
    while(fast != NULL && fast->data != y){
        fast=fast->next;
    }
    if(slow == NULL || fast == NULL){
        return;
    }
    int temp=slow->data;
    slow->data=fast->data;
    fast->data=temp;
}

#Rotate the Doubly Linked List by K elements
Node* rotateByK(Node* head, int k)
{
  if(head == nullptr || head->next == nullptr){
      return nullptr;
  }  
    Node *temp=head;
    int c=0;
    while(temp->next != NULL){
        temp=temp->next;
        c++;
    }
    if(c <= k){
        return head;
    }
    while(k--){
        Node *t=temp;
        temp=temp->prev;
        t->next = head;
        head->prev=t;
        head=t;
        temp->next=nullptr;
        t->prev=nullptr;
    }
    return head;
}

#Rearrange the Even-Odd Nodes of Doubly Linked List
struct Node* rearrangeList(struct Node* head){
    Node *temp = head;
    int index=1;
    Node *odds = NULL,*odde=NULL;
    Node *evens=NULL,*evene=NULL;
    while(temp != NULL){
        if(index%2 == 0){
            if(evens == NULL){
                evens=temp;
                evene=temp;
            }
            else{
                evene->next=temp;
                temp->prev=evene;
                evene=temp;
            }
        }
        else{
             if(odds == NULL){
                odds=temp;
                odde=temp;
            }
            else{
                odde->next=temp;
                temp->prev=odde;
                odde=temp;
            }
        }
        index++;
        temp=temp->next;
    }
    if(evene != NULL){
        evene->next=NULL;
    }
    if(odde != NULL){
        odde->next=NULL;
    }
    if(evene != NULL){
        evene->next=odds;
    }
    if(odds != NULL){
       odds->prev=evene;
    }
    return evens?evens:odds;
}

#print the List
void Linkedlist::forwardPrint()
  {
     Node *temp=head;
     if(temp==NULL){
         return ;
     }
     while(temp!=NULL){
         cout<<temp->data;
         if(temp->next!=NULL){
             cout<<"-";
         }
         temp=temp->next;
     }
     cout<<"-";
 } 
  void Linkedlist::backwardPrint(Node *head)
  {
      Node *temp=head;
      if(temp==NULL)return;
      backwardPrint(temp->next);
      cout<<temp->data;
      if(temp->data!=NULL){
      cout<<"-";
      }
  }

  #Copy first list to second list
  Node* Node::copyList()
{
    Node *temp=this;
    Node *head=nullptr;
    while(temp){
        Node *tempn= new Node(temp->data);
        if(!head){
            head=tempn;
        }else{
            Node *last=head;
            while(last->next!=NULL){
                last=last->next;
            }
            last->next=tempn;
        }
        temp=temp->next;
    }
    return head;
}

#Move the Smallest and largest to head and tail of list
void LinkedList:: shiftSmallLarge() 
{
     if(head == NULL || head->next == NULL)
        return;
    Node *temp=head;
     Node *min=head;
     Node *minp=NULL;
     while(temp->next != NULL){
         if(temp->next->data < min->data){
           min=temp->next;
             minp=temp;
         }
         temp=temp->next;
     }
     if(min != head){
         minp->next=min->next;
         min->next=head;
         head=min;
     }
     temp=head;
     Node *max=head;
     Node *maxp=NULL;
     while(temp->next != NULL){
         if(temp->next->data > max->data){
             max=temp->next;
             maxp=temp;
         }
         temp=temp->next;
     }
     if(max != temp){
         maxp->next=max->next;
         temp->next=max;
         max->next=NULL;
     }
}

#Check List for Palindrome
int List::checkPalindrome() {
  stack<int>s;
    Node *temp=head;
    while(temp != NULL){
        s.push(temp->data);
        temp=temp->next;
    }
    Node *cur=head;
    while(cur != NULL){
        if(s.top() != cur->data){
            return 0;
        }
        else{
           s.pop();
            cur=cur->next;
        }
    }
    return 1;
}

#Find the loop in Linked list
int loopInList(Node* head) {
  Node *small = head;
    Node *big = head;
    int c=0;
    while(big != NULL && big->next != NULL){
        small=small->next;
        big=big->next->next;
        if(big == small){
            c=1;
            while(small->next != big){
                c++;
                small=small->next;
            }
            return c;
        }
    }
}

#reverse a linked List
#include<stack>
void LinkedList::reverseList() {
    stack<int>s;
    Node *temp=head;
    while(temp != NULL){
       s.push(temp->data);
        temp=temp->next;
    }
    temp=head;
    while(temp != NULL){
      temp->data=s.top();
        s.pop();
        temp=temp->next;
    }
}

#Add Two Numbers Represented by Lists
LinkedList LinkedList::addListNumbers(LinkedList& list2) {
    Node *head1 = head;
    Node *head2 = list2.head;
    int sum,num=0,carry=0;
    LinkedList l3;
    while(head1 != NULL && head2 != NULL){
       sum = head1->data + head2->data + carry;
        num=sum%10;
        carry=sum/10;
        l3.insertEnd(num);
        head1=head1->next;
        head2=head2->next;
    }
    while(head1 != NULL){
        sum = head1->data + carry;
        num = sum%10;
        carry=sum/10;
        l3.insertEnd(num);
        head1=head1->next;
    }
     while(head2 != NULL){
        sum = head2->data + carry;
        num = sum%10;
        carry=sum/10;
        l3.insertEnd(num);
        head2=head2->next;
    }
    while(carry != 0){
        sum = carry;
        num = sum %10;
        carry=sum/10;
        l3.insertEnd(num);
    }
return l3;
}

#Delete a Node in Linked list given access to only that Node
void LinkedList::deleteNode(Node* node) {
    if(node == NULL || node->next == NULL)
        return;
Node  *temp=node->next;
    int res=temp->data;
    temp->data=node->data;
    node->data=res;
    node->next=node->next->next;
    delete temp;
}

