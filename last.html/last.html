#2nd maximimum in array 
int main()
{
    // Write your code here
    int n;
    cin>>n;
    int arr[n];
    for(int i=0;i<n;i++){
        cin>>arr[i];
    }
    int max=arr[0];
    int max2=0;
    for(int i=0;i<n;i++){
        if(arr[i]>max){
            max2=max;
            max=arr[i];
        }
        if(arr[i]<max && arr[i]>max2){
            max2=arr[i];
        }
    }
cout<<max2;
    return 0;
}

#maximum frequency
int maxFrequency(int A[], int n) {
  // Write your code here
  int arr[1001]={0};
    for(int i=0;i<n;i++){
        arr[A[i]]++;
    }
    int maxf=-1, maxe;
    for(int i=0;i<1001;i++){
        if(arr[i]>maxf){
            maxf=arr[i];
            maxe=i;
        }
    }
    return maxe;
}

#count negative pos even odd
void countAndPrint(int x[],int n){
  //write your code here
    int p=0,ne=0,e=0,o=0;
    for(int i=0;i<n;i++){
        if(x[i]<0){
            ne++;
        }
        if(x[i]>0){
            p++;
        }
        if(x[i]%2==0){
            e++;
        }
        if(x[i]%2!=0){
            o++;
        }
    }
  cout<<p<<endl<<ne<<endl<<e<<endl<<o<<endl;
}

#check if two arrays are equal  
#include <algorithm>  
bool ArrayComparator:: areArraysEqual()
     {
      sort(arr1,arr1+size);
      sort(arr2,arr2+size);
    for(int i=0;i<size;i++){
      if(arr1[i]!=arr2[i]){
          return false;
      }
    }
       return true;
     }

#move the elements 
void swap(int &a,int &b){
    int c=a;
    a=b;
    b=c;
}
void Result::moveElements()
{
    int pos=0;
    for(int i=0;i<size;i++){
        if(arr[i]>=0){
            for(int k=i;k>pos;k--){
                swap(arr[k],arr[k-1]);
            }
            pos++;
        }
    }
}


#string length
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main()
{
    int n,l;
    cin>>n;
    while(n--){
        string str;
        cin>>str;
        l=str.length();
        cout<<l<<endl;
    }
   return 0;
}

#strmp function 
int StringCmp::strcmp() {
    for(int i=0;i<str1.size() && i<str2.size();i++){
        if(str1[i] != str2[i]){
            return str1[i]-str2[i];
        }
    }
  return 0;
}

#strat function 
void strcatCode(char* str1, char* str2) {
  // Write your code here
    while(*str1){
        *str1++;
    }
    while(*str2){
        *str1++=*str2++;
    }
  *str1='\0';
}

#unique characyrrs or not
// Return true if string contains all unique characters, else return false
bool isUniqueChars(string str){
  // Write your code here
    int flag=0;
    int n=str.length();
    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            if(str[i]==str[j]){
                flag=1;
            }
        }
    }
    if (flag==1){
        return false;
    }
    else {
        return true;
    }
}

#string is palindrom
// Return true if the string is palindrome, else return false
bool isPalindrome(string str) {
  // Write your code here
  int l=str.length();
    for(int i=0,j=l-1;i<l;i++,j--){
        if(str[i]!=str[j]){
            return 0;
        }
    }
    return 1;
}

#reverse a string   
// Do not print anything, just reverse the given string
void reverseString (string &str) {
  // Write your code here
    int l=str.length();
    int start=0;
    int end=l-1;
    while(start<end){
        char temp=str[start];
        str[start]=str[end];
        str[end]=temp;
        start++;
        end--;   
    }
}

#count words
int countWords(string str) {
  // Write your code here
    int l=str.length();
    int count=0;
    if(l==0){
        count=-1;
    }
    for(int i=0;i<l;i++){
        if(str[i]!=' '&&str[i+1]==' '){
            count++;
        }
    }
    return count+1;
}

#reverse the words of string
void revWordsString(string str) {
  int start=0;
    int end=0;
    int l=str.length();
    for(int i=0;i<=l;i++){
        if(str[i]==' ' || i==l){
            end=i-1;
            while(start<end){
                char temp=str[start];
                str[start]=str[end];
                str[end]=temp;
                start++;
                end--;
            }
            start=i+1;
        }
    }
  cout<<str;
}

#first unique character
#include<unordered_map>
int firstUniqueChar(string str) {
    unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<str.size();i++){
        if(s[str[i]] == 1){
            return i;
        }
    }
    return -1;
}

#fins all pairs with k diffrences
#include<unordered_map>
int getPairsCount(int arr[], int n, int k) {
unordered_map<int,int> s;
    for(int i=0;i<n;i++){
        s[arr[i]]++;
    }
    int c=0;
    for(int i=0;i<n;i++){
        int t=arr[i]-k;
        if(s.find(t) != s.end()){
            c++;
        }
    }
    return c;
}

#find out the winner
#include<unordered_map>
string inspectStrings(vector<string> words) {
    map<string,int>s;
for(int i=0;i<words.size();i++){
    s[words[i]]++;
}  
    int max=0;
    string r;
    for(auto i:s){
        if(i.second >= max){
            r=i.first;
            max=i.second;
        }
    }
    return r;
}

#unique chracters or not
// Return true if string contains all unique characters, else return false
#include<unordered_map>
bool isUniqueChars(string str){
unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<s.size();i++){
        if(s[str[i]]>1){
            return false;
        }
    }
return true;
}

#frequency of each character
void countFrequency(string str) {
unordered_map<char,int>s;
    for(int i=0;i<str.size();i++){
        s[str[i]]++;
    }
    for(int i=0;i<str.size();i++){
        if(s[str[i]]>=1){
            cout<<str[i]<<s[str[i]]<<" ";
            s[str[i]]=0;
    }
}
}

#kth distinct elements
int kthDistinctElement(vector<int> arr, int n, int k) {
  unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        s[arr[i]]++;
    }
    int c=0;
    for(int i=0;i<n;i++){
        if(s[arr[i]] == 1){
            c++;
        }
        if(c == k){
            return arr[i];
        }
    }
    return 0;
}

#maximum frequency in sequence
int maxFrequency(int A[], int n) {
map<int,int>s;
    for(int i=0;i<n;i++){
        s[A[i]]++;
    }
    int max=0;
    int r=-1;
  for(auto i:s){
      if(i.second > max){
         max=i.second;
         r=i.first;
      }
  }
    return r;
}

#check if two arrays are equal or not
int arraysEqualorNot(vector<int> A, vector<int> B) {
  sort(A.begin(),A.end());
    sort(B.begin(),B.end());
    for(int i=0;i<A.size();i++){
        if(A[i] != B[i]){
            return 0;
        }
    }
    return 1;
}

#pair with given sum
// Return true if a pair with the sum k is found, else return false
bool pairSum(int arr[], int n, int k) {
  unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        int t=k-arr[i];
        if(s.find(t) != s.end()){
            return true;
        }
        s[arr[i]]++;
    }
    return false;
}

#aaray pair sum divisibility problem
int isArrayDivisibleInPairs(int a[], int n, int k){
unordered_map<int,int>s;
    for(int i=0;i<n;i++){
        int r=a[i]%k;
        if(r<0){
            r+=k;
        }
        s[r]++;
    }
    if(s[0]%2!=0){
        return false;
    }
for(int i=1;i<k/2;i++){
    if(s[i] != s[k-1]){
        return false;
    }
}
return true;
}

#largest subaaray with zero sum
int largSubArray(int* arr, int n){
 unordered_map<int,int>s;
    int sum=0;
    int maxl=-1;
    for(int i=0;i<n;i++){
        sum+=arr[i];
        if(sum == 0){
            maxl=i+1;
        }
        if(s.find(sum) != s.end()){
            int max=i-s[sum];
            if(max>maxl){
                maxl=max;
            }
        }
        else{
            s[sum]=i;
        }
    }
    return maxl;
}

#create a binary tree from array
// Complete the buildTree() function which is a member function of the class BinaryTree.
void BinaryTree:: buildTree(int arr[], int n) {
    if(n == 0){
        return ;
    }
  queue <TreeNode*>q;
    root = new TreeNode(arr[0]);
    q.push(root);
    int inde=1;
    while(inde<n){
        TreeNode *temp=q.front();
           q.pop();
        if(inde<n){
            temp->left = new TreeNode (arr[inde++]);
            q.push(temp->left);
        }
         if(inde<n){
             temp->right=new TreeNode (arr[inde++]);
             q.push(temp->right);
         }
    }
}

#print binary tree in level order transversal
void Tree::printLevelWise() {
    if( root == NULL){
        return ;
    }
  queue<Node*>q;
    q.push(root);
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size;i++){
      Node *temp=q.front();
        q.pop();
        cout<<temp->data;          
        if(i != (size-1)){
            cout<<" ";
        }
        if(temp->left){
            q.push(temp->left);
        }
        if(temp->right){
            q.push(temp->right);
        }
    }
        cout<<endl;
    }
}

#print nodes at odd level of binary tree
void printOdd(Node* root){
    if(root == NULL){
        return ;
    }
    queue<Node*>q;
    q.push(root);
    int ind=1;
    while(!q.empty()){
      int size=q.size();
        for(int i=0;i<size;i++){
            Node *temp=q.front();
            q.pop();
            if(ind%2==1){
                cout<<temp->data<<" ";
            }
            if(temp->left){
                q.push(temp->left);
            }
            if(temp->right){
                q.push(temp->right);
            }
        }
        ind++;
    }
}

#Complete the inorder(), preorder() and postorder() functions for traversal with recursion
 void inorder(Node *root) {
if(root == NULL){
    return ;
}
      inorder(root->left);
      cout<<root->data<<" ";
      inorder(root->right);
  }
   void  preorder(Node *root) {
       if(root == NULL){
    return ;
}
      cout<<root->data<<" ";
       preorder(root->left);
      preorder(root->right);
    }
    void  postorder(Node *root) {
     if(root == NULL){
    return ;
}
        postorder(root->left);
        postorder(root->right);
        cout<<root->data<<" ";
    }

#Count the number of leaf and non-leaf nodes in a binary tree
// These are the functions of the class BinaryTree in head and complete it in body.
int BinaryTree::countLeafs(TreeNode* node) {
if(node == nullptr){
    return 0;
}
    if(node->left == nullptr && node->right == nullptr){
        return 1;
    }
    return countLeafs(node->left) + countLeafs(node->right);
}
int BinaryTree::countNonLeafs(TreeNode* node) {
if(node == nullptr){
    return 0;
}
    if(node->left == nullptr && node->right == nullptr){
        return 0;
    }
    return countNonLeafs(node->left) + countNonLeafs(node->right)+1;
}

#Print all paths to leaves and their details of a binary tree
void printAllPaths(Node *root,vector<int>path){
      static int count=0;
      if(root == NULL){
      return ;
  }
      path.push_back(root->data);
      if(root->left == NULL && root->right == NULL){
          for(int i=0;i<path.size();i++){
              cout<<path[i]<<" ";
          }
          cout<<path.size()-1<<endl;
          count++;
          path.pop_back();
          return ;
      }
      printAllPaths(root->left,path);
      printAllPaths(root->right,path);
      path.pop_back();
      if(path.empty()){
          cout<<count<<endl;
      }
  }
void printAllPaths(Node* root) {
  if(root == NULL){
      return ;
  }
    vector<int>path;
  printAllPaths(root,path);
}

#Find the right node of a given node
int BinaryTree::findRightSibling(int key) {
    if(root->data == key){
        return -1;
    }
    queue<Node*>q;
    q.push(root);
    while(!q.empty()){
      int size=q.size();
         while(size>0){
            Node *temp=q.front();
             q.pop();
            if(temp->data == key){
                if(!q.empty() && size != 1){
                    Node *r=q.front();
                    q.pop();
                    return r->data;
                }
                else{
                    return -1;
                }
            }
             if(temp->left){
                 q.push(temp->left);
             }
             if(temp->right){
                 q.push(temp->right);
             }
             size--;
         }
    }
    return -1;
}

#Given list is circular or not
int ListCircularCheck::isCircular(Node* head) {
    if(head == nullptr){
        return 1;
    }
    Node *slow=head;
    Node *fast=head;
    while(fast != nullptr && fast->next != nullptr){
        slow=slow->next;
        fast=fast->next->next;
    if(slow == head){
        return 1;
    }
    if(fast == slow){
        return 0;
    }
    }
}

#Insert Nodes in a Circular Linked List
Node* insertBeg(Node* head, int data){
    Node *newnode =new Node(data);
    if(head == NULL){
        head=newnode;
        newnode->next=head;
        return head;
    }
    Node *temp=head;
    while(temp->next != head){
      temp=temp->next;
    }
    temp->next=newnode;
    newnode->next=head;
    head=newnode;
    return head;
}
Node* insertEnd(Node* head, int data){
     Node *newnode =new Node(data);
      if(head == NULL){
          head=newnode;
          newnode->next=head;
          return head;
      }
    Node *temp=head;
    while(temp->next != head){
        temp=temp->next;
    }
    temp->next=newnode;
    newnode->next=head;
    return head;
}

#Delete in Circular Linked List
void CircularLinkedList::deleteBeg(){
Node *temp=head;
    while(temp->next != head){
        temp=temp->next;
    }
    Node *te=head;
    temp->next=head->next;
    head=head->next;
    delete te;
}
void CircularLinkedList::deleteEnd(){
   Node *temp=head;
    while(temp->next->next != head){
        temp=temp->next;
    }
    Node *res=temp->next;
    temp->next=head;
    delete res;
}

#Count the Number of Nodes in Circular Linked List
int LinkedList::countNodes() {
    if(head == nullptr || head->next == nullptr){
        return 0;
    }
  int c=1;
    Node *temp=head;
    while(temp->next != head)
    {
        temp=temp->next;
          c++;
    }
    return c;
}

#Insert in a sorted circular linked list
void CircularLinkedList::insertSorted(int newData) {
      Node *newnode = new Node(newData);
     if(head == NULL){
         newnode->next=newnode;
         head=newnode;
     }
         Node *temp=head;
          if(newData < head->data){
              while(temp->next != head){
                  temp=temp->next;
              }
              temp->next=newnode;
              newnode->next=head;
              head=newnode;
              return;
          }
         while(temp->next != head && temp->next->data < newData){
             temp=temp->next;
         }
         newnode->next=temp->next;
     temp->next=newnode;
 }

 #Split the Circular Linked List in two parts
 CircularLinkedList* CircularLinkedList::splitLinkedList()
    {
    CircularLinkedList *newnode = new CircularLinkedList();
    if(head == nullptr){
        newnode->head=nullptr;
        return newnode;
    }
    LinkNode *tail=head;
    while(tail->next !=head){
        tail=tail->next;
    }
    LinkNode *slow=head;
    LinkNode *fast=head;
    while(fast->next->next != head){
        slow=slow->next;
        fast=fast->next->next;
    }
    newnode->head=slow->next;
    slow->next=head;
    tail->next=newnode->head;
    return newnode;
}